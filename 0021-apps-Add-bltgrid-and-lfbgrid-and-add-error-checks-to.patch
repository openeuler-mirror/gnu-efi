From 5ec879ace760faacfa940a1933e0339e8f3811bd Mon Sep 17 00:00:00 2001
From: Peter Jones <pjones@redhat.com>
Date: Tue, 13 Mar 2018 15:20:31 -0400
Subject: [PATCH 21/25] apps: Add bltgrid and lfbgrid, and add error checks to
 modelist

This adds bltgrid and lfbgrid, which draw checkerboards using GOP's
Blt() and linear framebuffer, respectively, and adds some error checks
to modelist.efi.

Signed-off-by: Peter Jones <pjones@redhat.com>
Signed-off-by: Nigel Croxon <ncroxon@redhat.com>
---
 apps/bltgrid.c  | 131 +++++++++++++++++++++++++++++++++++++++++++
 apps/lfbgrid.c  | 170 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 apps/modelist.c |  56 +++++++++----------
 apps/Makefile   |   3 +-
 4 files changed, 328 insertions(+), 32 deletions(-)
 create mode 100644 apps/bltgrid.c
 create mode 100644 apps/lfbgrid.c

diff --git a/apps/bltgrid.c b/apps/bltgrid.c
new file mode 100644
index 00000000000..2adde6a3211
--- /dev/null
+++ b/apps/bltgrid.c
@@ -0,0 +1,131 @@
+#include <efi.h>
+#include <efilib.h>
+
+extern EFI_GUID GraphicsOutputProtocol;
+
+static void
+fill_boxes(UINT32 *PixelBuffer, UINT32 Width, UINT32 Height)
+{
+	UINT32 y, x = 0;
+	/*
+	 * This assums BGRR, but it doesn't really matter; we pick red and
+	 * green so it'll just be blue/green if the pixel format is backwards.
+	 */
+	EFI_GRAPHICS_OUTPUT_BLT_PIXEL Red = {0, 0, 0xff, 0},
+				      Green = {0, 0xff, 0, 0},
+				      *Color;
+
+	for (y = 0; y < Height; y++) {
+		Color = ((y / 32) % 2 == 0) ? &Red : &Green;
+		for (x = 0; x < Width; x++) {
+			if (x % 32 == 0 && x != 0)
+				Color = (Color == &Red) ? &Green : &Red;
+			PixelBuffer[y * Width + x] = *(UINT32 *)Color;
+		}
+	}
+}
+
+static void
+draw_boxes(EFI_GRAPHICS_OUTPUT_PROTOCOL *gop)
+{
+	int i, imax;
+	EFI_STATUS rc;
+	EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *info;
+	UINTN NumPixels;
+	UINT32 *PixelBuffer;
+	UINT32 BufferSize;
+
+	if (gop->Mode) {
+		imax = gop->Mode->MaxMode;
+	} else {
+		Print(L"gop->Mode is NULL\n");
+		return;
+	}
+
+	for (i = 0; i < imax; i++) {
+		UINTN SizeOfInfo;
+		rc = uefi_call_wrapper(gop->QueryMode, 4, gop, i, &SizeOfInfo,
+					&info);
+		if (EFI_ERROR(rc) && rc == EFI_NOT_STARTED) {
+			Print(L"gop->QueryMode() returned %r\n", rc);
+			Print(L"Trying to start GOP with SetMode().\n");
+			rc = uefi_call_wrapper(gop->SetMode, 2, gop,
+				gop->Mode ? gop->Mode->Mode : 0);
+			rc = uefi_call_wrapper(gop->QueryMode, 4, gop, i,
+				&SizeOfInfo, &info);
+		}
+
+		if (EFI_ERROR(rc)) {
+			Print(L"%d: Bad response from QueryMode: %r (%d)\n",
+			      i, rc, rc);
+			continue;
+		}
+
+		if (CompareMem(info, gop->Mode->Info, sizeof (*info)))
+			continue;
+
+		NumPixels = info->VerticalResolution * info->HorizontalResolution;
+		BufferSize = NumPixels * sizeof(UINT32);
+
+		PixelBuffer = AllocatePool(BufferSize);
+		if (!PixelBuffer) {
+			Print(L"Allocation of 0x%08lx bytes failed.\n",
+			      sizeof(UINT32) * NumPixels);
+			return;
+		}
+
+		fill_boxes(PixelBuffer,
+			   info->HorizontalResolution, info->VerticalResolution);
+
+		uefi_call_wrapper(gop->Blt, 10, gop,
+				  (EFI_GRAPHICS_OUTPUT_BLT_PIXEL *)PixelBuffer,
+				  EfiBltBufferToVideo,
+				  0, 0, 0, 0,
+				  info->HorizontalResolution,
+				  info->VerticalResolution,
+				  0);
+		return;
+	}
+	Print(L"Never found the active video mode?\n");
+}
+
+static EFI_STATUS
+SetWatchdog(UINTN seconds)
+{
+	EFI_STATUS rc;
+	rc = uefi_call_wrapper(BS->SetWatchdogTimer, 4, seconds, 0x1ffff,
+				0, NULL);
+	if (EFI_ERROR(rc)) {
+		CHAR16 Buffer[64];
+		StatusToString(Buffer, rc);
+		Print(L"Bad response from QueryMode: %s (%d)\n", Buffer, rc);
+	}
+	return rc;
+}
+
+EFI_STATUS
+efi_main (EFI_HANDLE image_handle, EFI_SYSTEM_TABLE *systab)
+{
+	EFI_STATUS rc;
+	EFI_GRAPHICS_OUTPUT_PROTOCOL *gop;
+
+	InitializeLib(image_handle, systab);
+
+	SetWatchdog(10);
+
+	rc = LibLocateProtocol(&GraphicsOutputProtocol, (void **)&gop);
+	if (EFI_ERROR(rc)) {
+		Print(L"Could not locate GOP: %r\n", rc);
+		return rc;
+	}
+
+	if (!gop) {
+		Print(L"LocateProtocol(GOP, &gop) returned %r but GOP is NULL\n", rc);
+		return EFI_UNSUPPORTED;
+	}
+
+	draw_boxes(gop);
+
+	SetWatchdog(0);
+	return EFI_SUCCESS;
+}
diff --git a/apps/lfbgrid.c b/apps/lfbgrid.c
new file mode 100644
index 00000000000..53a255afbb9
--- /dev/null
+++ b/apps/lfbgrid.c
@@ -0,0 +1,170 @@
+#include <efi.h>
+#include <efilib.h>
+
+extern EFI_GUID GraphicsOutputProtocol;
+
+#define be32_to_cpu(x) __builtin_bswap32(x)
+
+static void
+fill_boxes(UINT32 *PixelBuffer, UINT32 Width, UINT32 Height, UINT32 Pitch,
+	   EFI_GRAPHICS_PIXEL_FORMAT Format, EFI_PIXEL_BITMASK Info )
+{
+	UINT32 Red, Green;
+	UINT32 y, x, color;
+
+	switch(Format) {
+	case PixelRedGreenBlueReserved8BitPerColor:
+		Red = be32_to_cpu(0xff000000);
+		Green = be32_to_cpu(0x00ff0000);
+		break;
+	case PixelBlueGreenRedReserved8BitPerColor:
+		Red = be32_to_cpu(0x0000ff00);
+		Green = be32_to_cpu(0x00ff0000);
+		break;
+	case PixelBitMask:
+		Red = Info.RedMask;
+		Green = Info.GreenMask;
+		break;
+	case PixelBltOnly:
+		return;
+	default:
+		Print(L"Invalid pixel format\n");
+		return;
+	}
+
+	for (y = 0; y < Height; y++) {
+		color = ((y / 32) % 2 == 0) ? Red : Green;
+		for (x = 0; x < Width; x++) {
+			if (x % 32 == 0 && x != 0)
+				color = (color == Red) ? Green : Red;
+			PixelBuffer[y * Pitch + x] = color;
+		}
+	}
+}
+
+static void
+draw_boxes(EFI_GRAPHICS_OUTPUT_PROTOCOL *gop)
+{
+	int i, imax;
+	EFI_STATUS rc;
+	EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *info;
+	UINTN NumPixels;
+	UINT32 *PixelBuffer;
+	UINT32 CopySize, BufferSize;
+#if defined(__x86_64__) || defined(__aarch64__)
+	UINT64 FrameBufferAddr;
+#elif defined(__i386__) || defined(__arm__)
+	UINT32 FrameBufferAddr;
+#else
+#error YOUR ARCH HERE
+#endif
+
+	if (gop->Mode) {
+		imax = gop->Mode->MaxMode;
+	} else {
+		Print(L"gop->Mode is NULL\n");
+		return;
+	}
+
+	for (i = 0; i < imax; i++) {
+		UINTN SizeOfInfo;
+		rc = uefi_call_wrapper(gop->QueryMode, 4, gop, i, &SizeOfInfo,
+					&info);
+		if (EFI_ERROR(rc) && rc == EFI_NOT_STARTED) {
+			Print(L"gop->QueryMode() returned %r\n", rc);
+			Print(L"Trying to start GOP with SetMode().\n");
+			rc = uefi_call_wrapper(gop->SetMode, 2, gop,
+				gop->Mode ? gop->Mode->Mode : 0);
+			rc = uefi_call_wrapper(gop->QueryMode, 4, gop, i,
+				&SizeOfInfo, &info);
+		}
+
+		if (EFI_ERROR(rc)) {
+			Print(L"%d: Bad response from QueryMode: %r (%d)\n",
+			      i, rc, rc);
+			continue;
+		}
+
+		if (CompareMem(info, gop->Mode->Info, sizeof (*info)))
+			continue;
+
+		NumPixels = info->VerticalResolution * info->PixelsPerScanLine;
+		BufferSize = NumPixels * sizeof(UINT32);
+		if (BufferSize == gop->Mode->FrameBufferSize) {
+			CopySize = BufferSize;
+		} else {
+			CopySize = BufferSize < gop->Mode->FrameBufferSize ?
+				BufferSize : gop->Mode->FrameBufferSize;
+			Print(L"height * pitch * pixelsize = %lu buf fb size is %lu; using %lu\n",
+			      BufferSize, gop->Mode->FrameBufferSize, CopySize);
+		}
+
+		PixelBuffer = AllocatePool(BufferSize);
+		if (!PixelBuffer) {
+			Print(L"Allocation of 0x%08lx bytes failed.\n",
+			      sizeof(UINT32) * NumPixels);
+			return;
+		}
+
+		fill_boxes(PixelBuffer, info->HorizontalResolution,
+			   info->VerticalResolution, info->PixelsPerScanLine,
+			   info->PixelFormat, info->PixelInformation);
+
+		if (info->PixelFormat == PixelBltOnly) {
+			Print(L"No linear framebuffer on this device.\n");
+			return;
+		}
+#if defined(__x86_64__) || defined(__aarch64__)
+		FrameBufferAddr = (UINT64)gop->Mode->FrameBufferBase;
+#elif defined(__i386__) || defined(__arm__)
+		FrameBufferAddr = (UINT32)(UINT64)gop->Mode->FrameBufferBase;
+#else
+#error YOUR ARCH HERE
+#endif
+
+		CopyMem((VOID *)FrameBufferAddr, PixelBuffer, CopySize);
+		return;
+	}
+	Print(L"Never found the active video mode?\n");
+}
+
+static EFI_STATUS
+SetWatchdog(UINTN seconds)
+{
+	EFI_STATUS rc;
+	rc = uefi_call_wrapper(BS->SetWatchdogTimer, 4, seconds, 0x1ffff,
+				0, NULL);
+	if (EFI_ERROR(rc)) {
+		CHAR16 Buffer[64];
+		StatusToString(Buffer, rc);
+		Print(L"Bad response from QueryMode: %s (%d)\n", Buffer, rc);
+	}
+	return rc;
+}
+
+EFI_STATUS
+efi_main (EFI_HANDLE image_handle, EFI_SYSTEM_TABLE *systab)
+{
+	EFI_STATUS rc;
+	EFI_GRAPHICS_OUTPUT_PROTOCOL *gop;
+
+	InitializeLib(image_handle, systab);
+
+	SetWatchdog(10);
+
+	rc = LibLocateProtocol(&GraphicsOutputProtocol, (void **)&gop);
+	if (EFI_ERROR(rc)) {
+		Print(L"Could not locate GOP: %r\n", rc);
+		return rc;
+	}
+
+	if (!gop) {
+		Print(L"LocateProtocol(GOP, &gop) returned %r but GOP is NULL\n", rc);
+		return EFI_UNSUPPORTED;
+	}
+
+	draw_boxes(gop);
+
+	SetWatchdog(0);
+	return EFI_SUCCESS;
+}
diff --git a/apps/modelist.c b/apps/modelist.c
index 8d816d1d9da..26892e1d5f5 100644
--- a/apps/modelist.c
+++ b/apps/modelist.c
@@ -3,57 +3,44 @@
 
 extern EFI_GUID GraphicsOutputProtocol;
 
-static int memcmp(const void *s1, const void *s2, UINTN n)
-{
-	const unsigned char *c1 = s1, *c2 = s2;
-	int d = 0;
-
-	if (!s1 && !s2)
-		return 0;
-	if (s1 && !s2)
-		return 1;
-	if (!s1 && s2)
-		return -1;
-
-	while (n--) {
-		d = (int)*c1++ - (int)*c2++;
-		if (d)
-			break;
-	}
-	return d;
-}
-
 static void
 print_modes(EFI_GRAPHICS_OUTPUT_PROTOCOL *gop)
 {
 	int i, imax;
 	EFI_STATUS rc;
 
-	imax = gop->Mode->MaxMode;
+	if (gop->Mode) {
+		imax = gop->Mode->MaxMode;
+		Print(L"GOP reports MaxMode %d\n", imax);
+	} else {
+		Print(L"gop->Mode is NULL\n");
+		imax = 1;
+	}
 
-	Print(L"GOP reports MaxMode %d\n", imax);
 	for (i = 0; i < imax; i++) {
 		EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *info;
 		UINTN SizeOfInfo;
 		rc = uefi_call_wrapper(gop->QueryMode, 4, gop, i, &SizeOfInfo,
 					&info);
 		if (EFI_ERROR(rc) && rc == EFI_NOT_STARTED) {
+			Print(L"gop->QueryMode() returned %r\n", rc);
+			Print(L"Trying to start GOP with SetMode().\n");
 			rc = uefi_call_wrapper(gop->SetMode, 2, gop,
-				gop->Mode->Mode);
+				gop->Mode ? gop->Mode->Mode : 0);
 			rc = uefi_call_wrapper(gop->QueryMode, 4, gop, i,
 				&SizeOfInfo, &info);
 		}
 
 		if (EFI_ERROR(rc)) {
-			CHAR16 Buffer[64];
-			StatusToString(Buffer, rc);
-			Print(L"%d: Bad response from QueryMode: %s (%d)\n",
-				i, Buffer, rc);
+			Print(L"%d: Bad response from QueryMode: %r (%d)\n",
+			      i, rc, rc);
 			continue;
 		}
-		Print(L"%c%d: %dx%d ", memcmp(info,gop->Mode->Info,sizeof(*info)) == 0 ? '*' : ' ', i,
-			info->HorizontalResolution,
-			info->VerticalResolution);
+		Print(L"%c%d: %dx%d ",
+		      (gop->Mode &&
+		       CompareMem(info,gop->Mode->Info,sizeof(*info)) == 0
+		       ) ? '*' : ' ',
+		      i, info->HorizontalResolution, info->VerticalResolution);
 		switch(info->PixelFormat) {
 			case PixelRedGreenBlueReserved8BitPerColor:
 				Print(L"RGBR");
@@ -104,8 +91,15 @@ efi_main (EFI_HANDLE image_handle, EFI_SYSTEM_TABLE *systab)
 	SetWatchdog(10);
 
 	rc = LibLocateProtocol(&GraphicsOutputProtocol, (void **)&gop);
-	if (EFI_ERROR(rc))
+	if (EFI_ERROR(rc)) {
+		Print(L"Could not locate GOP: %r\n", rc);
 		return rc;
+	}
+
+	if (!gop) {
+		Print(L"LocateProtocol(GOP, &gop) returned %r but GOP is NULL\n", rc);
+		return EFI_UNSUPPORTED;
+	}
 
 	print_modes(gop);
 
diff --git a/apps/Makefile b/apps/Makefile
index 5fffd4254c8..4e26444c469 100644
--- a/apps/Makefile
+++ b/apps/Makefile
@@ -61,7 +61,8 @@ LOADLIBES	+= -T $(LDSCRIPT)
 TARGET_APPS = t.efi t2.efi t3.efi t4.efi t5.efi t6.efi \
 	      printenv.efi t7.efi t8.efi tcc.efi modelist.efi \
 	      route80h.efi drv0_use.efi AllocPages.efi exit.efi \
-	      FreePages.efi setjmp.efi debughook.efi debughook.efi.debug
+	      FreePages.efi setjmp.efi debughook.efi debughook.efi.debug \
+	      bltgrid.efi lfbgrid.efi
 TARGET_BSDRIVERS = drv0.efi
 TARGET_RTDRIVERS =
 
-- 
2.15.0

